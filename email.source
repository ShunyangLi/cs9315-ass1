-- create the email_in function for input
CREATE FUNCTION email_in(cstring)
   RETURNS EmailAddr
   AS '_OBJWD_/email'
   LANGUAGE C IMMUTABLE STRICT;


-- create the email_out function for oupt
CREATE FUNCTION email_out(EmailAddr)
   RETURNS cstring
   AS '_OBJWD_/email'
   LANGUAGE C IMMUTABLE STRICT;

-- now, we can create the type. The internallength specifies the size of the
-- memory block required to hold the type (we need two 8-byte doubles).
CREATE TYPE EmailAddr (
   internallength = variable,
   input = email_in,
   output = email_out
);


-----------------------------
-- Using the new type:
--	user-defined types can be used like ordinary built-in types.
-----------------------------

-- eg. we can use it in a table

CREATE TABLE test_email (
	a	EmailAddr,
	b	EmailAddr
);

-- data for user-defined types are just strings in the proper textual
-- representation.

INSERT INTO test_email VALUES ('JAS@CSE.unsw.edu.au', 'john-shepherd@hotmail.com');
INSERT INTO test_email VALUES ('jas@cse', 'x--@gmail.com');

SELECT * FROM test_email;


-- first, define the required operators
CREATE FUNCTION email_lt(EmailAddr, EmailAddr) RETURNS bool
   AS '_OBJWD_/email' LANGUAGE C IMMUTABLE STRICT;
CREATE FUNCTION email_le(EmailAddr, EmailAddr) RETURNS bool
   AS '_OBJWD_/email' LANGUAGE C IMMUTABLE STRICT;
CREATE FUNCTION email_eq(EmailAddr, EmailAddr) RETURNS bool
   AS '_OBJWD_/email' LANGUAGE C IMMUTABLE STRICT;
CREATE FUNCTION email_ge(EmailAddr, EmailAddr) RETURNS bool
   AS '_OBJWD_/email' LANGUAGE C IMMUTABLE STRICT;
CREATE FUNCTION email_gt(EmailAddr, EmailAddr) RETURNS bool
   AS '_OBJWD_/email' LANGUAGE C IMMUTABLE STRICT;
CREATE FUNCTION email_ne(EmailAddr, EmailAddr) RETURNS bool
  AS '_OBJWD_/email' LANGUAGE C IMMUTABLE STRICT;
CREATE FUNCTION email_sd(EmailAddr, EmailAddr) RETURNS bool
  AS '_OBJWD_/email' LANGUAGE C IMMUTABLE STRICT;
CREATE FUNCTION email_nsd(EmailAddr, EmailAddr) RETURNS bool
  AS '_OBJWD_/email' LANGUAGE C IMMUTABLE STRICT;

CREATE OPERATOR < (
   leftarg = EmailAddr, rightarg = EmailAddr, procedure = email_lt,
   commutator = > , negator = >= ,
   restrict = scalarltsel, join = scalarltjoinsel
);
CREATE OPERATOR <= (
   leftarg = EmailAddr, rightarg = EmailAddr, procedure = email_le,
   commutator = >= , negator = > ,
   restrict = scalarlesel, join = scalarlejoinsel
);
CREATE OPERATOR = (
   leftarg = EmailAddr, rightarg = EmailAddr, procedure = email_eq,
   commutator = = ,
   -- leave out negator since we didn't create <> operator
   negator = <> ,
   restrict = eqsel, join = eqjoinsel
);
CREATE OPERATOR >= (
   leftarg = EmailAddr, rightarg = EmailAddr, procedure = email_ge,
   commutator = <= , negator = < ,
   restrict = scalargesel, join = scalargejoinsel
);
CREATE OPERATOR > (
   leftarg = EmailAddr, rightarg = EmailAddr, procedure = email_gt,
   commutator = < , negator = <= ,
   restrict = scalargtsel, join = scalargtjoinsel
);

CREATE OPERATOR <> (
   leftarg = EmailAddr, rightarg = EmailAddr, procedure = email_ne,
   commutator = <> , negator = = ,
   restrict = neqsel, join = neqjoinsel
);


CREATE OPERATOR ~ (
   leftarg = EmailAddr, rightarg = EmailAddr, procedure = email_sd,
   commutator = ~ , negator = !~ ,
   restrict = eqsel, join = eqjoinsel
);

CREATE OPERATOR !~ (
   leftarg = EmailAddr, rightarg = EmailAddr, procedure = email_nsd,
   commutator = !~ , negator = ~ ,
   restrict = neqsel, join = neqjoinsel
);


-- create the support function too
CREATE FUNCTION email_cmp(EmailAddr, EmailAddr) RETURNS int4
   AS '_OBJWD_/email' LANGUAGE C IMMUTABLE STRICT;


CREATE FUNCTION email_hash_index(EmailAddr) RETURNS int4
   AS '_OBJWD_/email' LANGUAGE C IMMUTABLE STRICT;

-- now we can make the operator class
CREATE OPERATOR CLASS Email_ops
    DEFAULT FOR TYPE EmailAddr USING btree AS
        OPERATOR        1       < ,
        OPERATOR        2       <= ,
        OPERATOR        3       = ,
        OPERATOR        4       >= ,
        OPERATOR        5       > ,
        FUNCTION        1       email_cmp(EmailAddr, EmailAddr);


CREATE OPERATOR CLASS email_hash
    DEFAULT FOR TYPE EmailAddr USING hash AS
        OPERATOR        1       = ,
        FUNCTION        1       email_hash_index(EmailAddr);

-- now, we can define a btree index on Email types. First, let's populate
-- the table. Note that postgres needs many more tuples to start using the
-- btree index during selects.
INSERT INTO test_email VALUES ('j-a-shepherd@bargain-hunter.com', 'jas@a-very-silly-domain.org');
INSERT INTO test_email VALUES ('john1988@my-favourite.org', 'jas@cse');

CREATE INDEX test_email_bt ON test_email
   USING btree(a Email_ops);

CREATE INDEX test_email_hash ON test_email
   USING hash(a email_hash);

SELECT * from test_email where a = 'jas@cse.unsw.edu.au';
SELECT * from test_email where a < 'jas@cse.unsw.edu.au';
SELECT * from test_email where a > 'jas@cse.unsw.edu.au';


-- clean up the example
DROP TABLE test_email;
-- DROP TYPE EmailAddr CASCADE;
